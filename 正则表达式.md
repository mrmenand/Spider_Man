## 正则表达式

#### 1.1元字符
"." 这个元字符的含义是匹配除换行符的的任意字符  
"*" 代表的是数量  
"\b" 匹配单词的开始或者结束  
"\d" 匹配数字  
"\w" 匹配字母、数字、下划线或者汉字  
"\s" 匹配任意空白符，包括空格、制表符（Tab）、换行符、中文全角空格    
"^" 匹配字符串的开始   
”$" 匹配字符串的结尾   

#### 1.2字符转义 & 字符集合 
查找元字符本身的话，比如"."或者"*"，需要转义，写成"\." 或者"\\"  

正则表达式通过 **[]** 来实现自定义字符集合，[a,b,c,d,e]就是匹配abcde中任何一个，[.?!]匹配标点符号("." "?" 或"!")

#### 1.3重复 & 分支条件
**"*"** 重复零次或者更多次  
**{n}** 重复多次  
![常用限定符](https://github.com/mrmenand/Photograph/blob/master/spider/_20190117200914.png)

分支条件指的是有几种匹配规则，如果满足其中任意一种规则都应该城匹配，具体方法是用 **“|"** 把不同的规则隔开  

#### 1.4分组 & 反义
使用 **（）** 指定一个表达式可以看作一个分组，以分组的括号为标志，第一个出现的分组的组号为1，第二个为2
（?<name>exp）匹配exp,并捕获文本到名称为name的组里，也可从写成（？'name'exp）
方向引用分组捕获的内容，使用\k<name>

想匹配192.168.1.1这样的IP，可以这么写（（\d{1,3}）\.）{3}\d{1,3}   
\d{1,3} 代表着1 ~ 3 位的数字  
（（\d{1,3}）\.）{3} 表示将这样1 ~ 3 位的数字加上". 重复3次  
之后再加上\d{1,3}，表示1~3 的数字

查找除某一类字符集合之外的字符，需要用的反义，一般为**大写元字符**和 **^**
![]()

#### 1.5 贪心与懒惰 & 处理选项
当正则表达式中包含能接受重复的限定符时，通常都是匹配尽可能多的字符，这就是贪心模式
而可能匹配个数的情况，则需要用 **”？“** 来启动懒惰模式
![]()

处理选项大概有 忽略大小写re.I，多行模式re.M，单行模式，忽略空白


#### Python与正则
（？P<name>） 分组，除了原有编号再指定一个额外的别名
（？P=name） 引用别名为<name>的分组匹配到字符串
可以通过group()可以获取捕获的值
Python 通过re模板提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译Pattern对象，然后使用实例处理文本并获取匹配结果

re.compile(string,[,flags]) 
将一个正则表达式的字符串转化成Patternp匹配对象
pattern = re.compile()

re.match(pattern，string[,flags]) 
从输入参数string（匹配的字符串）的开头开始，尝试匹配pattern，只有在string起始位置匹配成功才有返回，反之，返回None

re.search(pattern，string[,flags])
扫描整个string查找匹配

re.split(pattern，string[,maxsplit]) 
按照能够匹配的子串将string分割后返回列表

re.findall(pattern，string[,flags])
搜索整个string，以列表形式返回能匹配的全部子串

re.finditer(pattern，string[,flags])
搜索整个string，以迭代器形式返回能匹配的全部匹配对象

re.sub(pattern,repl,string[,count])
使用repl替换string中每一个匹配的子串后返回替换后的字符串

